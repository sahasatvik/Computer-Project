\input{tex/ktourData}

\chapquote{``My project is 90\% done. I hope the second half goes as well."}{Scott W. Ambler}

\problem A {\em Knight's Tour} is a sequence of moves of a knight on a chessboard such that 
the {\em knight} visits every square only once. If the knight ends on a square that is one knight's move
from the beginning square, the tour is {\em closed} forming a closed loop, otherwise it is {\em open}.

There are many ways of constructing such paths on an empty board. On an $ 8\times 8$ board, there are no less
than $26,534,728,821,064$ {\em directed\footnote{Two tours along the same path that travel in opposite directions are counted separately, as are rotations and reflections.} closed} tours. Below is one of them.
\[\chessboard[boardfontsize=25pt,
			  setpieces={Nd4},
			  showmover=false,
			  arrow=to, linewidth=0.7pt, shorten=-1pt,
			  pgfstyle=straightmove,
			  markmoves=\ktour]\]

Construct a {\em Knight's Tour} ({\em open} or {\em closed}) on an $n \times n$ board, starting from
a given square.\\

{\em (Mark each square with the move number on which the knight landed on it.
Mark the starting square $1$.)}\clearpage

\solution

A knight on a chessboard can move to a square that is two squares away horizontally and one square vertically, or two squares vertically and one square horizontally.
\vspace{-5mm}
\[\chessboard[smallboard, maxfield=e5,
			  labelleft=false, labelbottom=false,
			  setpieces={Nc3},
			  showmover=false,
			  pgfstyle=straightmove,
			  linewidth=0.7pt,
			  markmoves={c3-b1, c3-d1, c3-e2, c3-a2, c3-a4, c3-e4, c3-b5, c3-d5}]
\chessboard[smallboard, maxfield=e5,
			  labelleft=false, labelbottom=false,
			  setpieces={Na3},
			  showmover=false,
			  linewidth=0.7pt,
			  pgfstyle=straightmove,
			  markmoves={a3-b1, a3-b5, a3-c2, a3-c4}]
\chessboard[smallboard, maxfield=e5,
			  labelleft=false, labelbottom=false,
			  setpieces={Na1},
			  showmover=false,
			  linewidth=0.7pt,
			  pgfstyle=straightmove,
			  markmoves={a1-b3, a1-c2}]
\]
\vspace{-5mm}

The mobility of a knight can make varies greatly with its position on the board --- near the centre, it can jump
to one of $8$ squares while when in a corner, it can jump to only $2$. On the other hand, the number of possible {\em sequences} of
squares a knight can traverse grows extremely quickly. Although it may seem that a simple {\em brute force} search can quickly find 
one of {\em trillions} of solutions, there are approximately $4 \times 10^{51}$ different paths to consider on an $8 \times 8$
board. For even larger boards, iterating through every possible path is clearly impractical.\citeneeded

This problem calls for implementing a {\em backtracking\footnote{Backtracking is a general algorithm for finding some or all solutions to some computational problems that incrementally builds candidates to the solutions, and abandons each partial candidate (``backtracks") as soon as it determines that the candidate cannot possibly be completed to a valid solution.} algorithm}, coupled with some {\em heuristic\footnote{A heuristic technique is any approach to problem solving that employs a practical method not guaranteed to be optimal or perfect, but sufficient for the immediate goals. Where finding an optimal solution is impossible or impractical, heuristic methods can be used to speed up the process of finding a satisfactory solution.}} to speed up the search. One such heuristic is {\em Warnsdorf's Rule}.
\begin{quote}
The knight is moved so that it always proceeds to the square from which the knight will have the {\em fewest} onward moves.
\end{quote}
This allows us to define a ranking alorithm for each possible path --- the positions which result in the smallest number of further moves, or is furthest away from the board's centre will be investigated first. In case of a tie, we can either proceed without making
any changes to the already existing positions, or introduce a random element. This has the effect of producing different results
on successive executions, giving a variety of solutions.

One drawback of resolving ties randomly is that an early ``wrong" choice in the position tree can force the calculation of every
resulting path without reaching a solution, effectively reducing the algorithm to a brute force search. This is especially problematic
for large boards, where it may take hours to backtrack and reach a solution. Thus, the ``randomness factor" should be adjusted according to the board size.

A high randomness can be useful for searching specifically for {\em closed tours}, as a randomness of $0$ simply produces the same solution every time (which may or may not be closed). Below are some tours generated by the program.
\vspace{-5mm}
\[
\chessboard[boardfontsize=16pt, maxfield=j10,
			  labelleft=false, labelbottom=false,
			  showmover=false,
			  arrow=to, linewidth=0.6pt, shorten=-1pt,
			  pgfstyle=straightmove,
			  markmoves=\ktourTen]
\chessboard[boardfontsize=10pt, maxfield=p16,
			  labelleft=false, labelbottom=false,
			  showmover=false,
			  arrow=to, linewidth=0.5pt, shorten=-1pt,
			  pgfstyle=straightmove,
			  markmoves=\ktourSixteen]
\]
\vspace{-8mm}

The tendency of the path to remain close to the edges of the board is clearly evident.

\sourcecode
\lstinputlisting{src/TourSolver.java}
\lstinputlisting{src/Position.java}
\lstinputlisting{src/KnightTour.java}

