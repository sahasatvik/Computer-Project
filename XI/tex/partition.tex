
\chapquote{``Elegance is not a dispensable luxury but a factor that decides between success and failure."}{Edsger W. Dijkstra}

\problem A {\em partition} of a positive integer $n$ is defined as a collection of other positive integers such that
their sum is equal to $n$. Thus, if $(a_1, a_2, \dots, a_k)$ is a partition of $n$,
\begin{equation*}
	n	\;=\;	a_1 + a_2 + \dots + a_k 			\tag{$a_i \in \mathbb{Z}^{+}$}
\end{equation*}

Display every {\em unique partition} of an inputted number.

\solution This problem can be solved elegantly using {\em recursion\footnote{Recursion occurs when a thing is defined in terms of itself or of its type.}}. Note that when partitioning a number $n$, we can calculate the partitions of $(n - 1)$ and append $1$ to each solution. Similarly, we can append $2$ to partitions of $(n - 2)$, $3$ to partitions of $(n - 3)$, and so on. By continuing in this fashion, all cases will be reduced to the single {\em base case} of finding the partitions of $1$, which trivially consist of only $1$ itself.

There is a slight flaw in this algorithm --- partitions are often repeated. This can be overcome by imposing the restriction that each new term has to be of a lesser magnitude than the previous. In this way, repeated partitions will be automatically discarded.

\sourcecode
\lstinputlisting{src/Partition.java}